defmodule Euler1To10 do
  @moduledoc """
    First 10 problems on project Euler
    https://projecteuler.net/archive
  """

  @doc """
    Question 1
    we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3,5,6, and 9.
    The sum of these multiples is 23.

    Find the sum of all the multiples of 3 or 5 below 1000.

  ## Examples

      iex> Euler_1_10.three_or_five(999)
      233168

  """
  @spec three_or_five(integer) :: non_neg_integer
  def three_or_five(n), do: three_or_five(n, 0)

  defp three_or_five(n, sum) when n > 0 and (rem(n, 5) == 0 or rem(n, 3) == 0) do
    n + three_or_five(n - 1, sum)
  end

  defp three_or_five(n, sum) when n > 0 do
    three_or_five(n - 1, sum)
  end

  defp three_or_five(n, _sum) when n <= 0, do: 0

  @doc """
    Question 2
    Each new term in the Fibonacci sequence is generated by adding the previous two terms.
    By starting with 1 and 2  the first 10 terms will be:

    1,2,3,5,8,13,21,34,55,89,...

    By considering the terms in the Fibonacci sequence whose values do not exceed four million,
    find the sum of the even-valued terms.

  ## Examples

      iex> Euler_1_10.even_fibonacci()
      233168

  """
  @spec even_fibonacci :: non_neg_integer
  def even_fibonacci, do: even_fibonacci(2, 1, 0)

  defp even_fibonacci(current, previous, sum) when rem(current, 2) == 0 and current < 4_000_000 do
    current + even_fibonacci(current + previous, current, sum)
  end

  defp even_fibonacci(current, previous, sum) when current < 4_000_000 do
    even_fibonacci(current + previous, current, sum)
  end

  defp even_fibonacci(current, _previous, sum)
       when rem(current, 2) == 0 and current == 4_000_000 do
    sum + current
  end

  defp even_fibonacci(current, _previous, sum) when current >= 4_000_000 do
    sum
  end

  @doc """
    Question 3
    The prime factors of 13195 are 5,7,13 and 29.

    What is the largest prime factor of the number 600_851_475_143?

    ## Examples

    iex> Euler_1_10.largest_prime(600_851_475_143)
    6857
  """
  @spec largest_prime(non_neg_integer) :: non_neg_integer
  def largest_prime(n) do
    n
    |> :math.sqrt()
    |> trunc()
    |> (&(&1..2)).()
    |> Enum.filter(&(rem(n, &1) == 0 && check_prime(&1)))
    |> hd()
  end

  defp check_prime(x) do
    2..(x - 1) |> Enum.all?(&(rem(x, &1) != 0))
  end

end
